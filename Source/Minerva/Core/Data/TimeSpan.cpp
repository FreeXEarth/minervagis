
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2008, Adam Kubach
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

#include "Minerva/Core/Data/TimeSpan.h"

#include "Usul/Factory/RegisterCreator.h"

using namespace Minerva::Core::Data;

USUL_FACTORY_REGISTER_CREATOR ( TimeSpan );

SERIALIZE_XML_DECLARE_TYPE_WRAPPER ( Minerva::Core::Data::Date );

///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

TimeSpan::TimeSpan() : BaseClass(),
  _begin ( boost::date_time::min_date_time ),
  _end ( boost::date_time::max_date_time )
{
  this->_addMember ( "first_date", _begin );
  this->_addMember ( "last_date",  _end );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

TimeSpan::TimeSpan ( const Date& begin, const Date& end ) : BaseClass(),
  _begin ( begin ),
  _end ( end )
{
  this->_addMember ( "first_date", _begin );
  this->_addMember ( "last_date",  _end );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

TimeSpan::~TimeSpan()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Set the beginning date.
//
///////////////////////////////////////////////////////////////////////////////

void TimeSpan::begin ( const Date& date )
{
  Guard guard ( this->mutex() );
  _begin = date;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the beginning date.
//
///////////////////////////////////////////////////////////////////////////////

TimeSpan::Date TimeSpan::begin() const
{
  Guard guard ( this->mutex() );
  return _begin;
}


///////////////////////////////////////////////////////////////////////////////
//
//  End date.
//
///////////////////////////////////////////////////////////////////////////////

void TimeSpan::end ( const Date& date )
{
  Guard guard ( this->mutex() );
  _end = date;
}


///////////////////////////////////////////////////////////////////////////////
//
//  End date.
//
///////////////////////////////////////////////////////////////////////////////

TimeSpan::Date TimeSpan::end() const
{
  Guard guard ( this->mutex() );
  return _end;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Is this time stamp visible over this time period?
//
///////////////////////////////////////////////////////////////////////////////

bool TimeSpan::isVisible ( const boost::posix_time::time_period& period ) const
{
  return this->_isVisible ( this->begin(), this->end(), period );
}
