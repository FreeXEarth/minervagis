
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2010, Adam Kubach
//  All rights reserved.
//  BSD License: http://www.opensource.org/licenses/bsd-license.html
//
///////////////////////////////////////////////////////////////////////////////

#include "Minerva/Plugins/GDAL/OGRReader.h"
#include "Minerva/Plugins/GDAL/OGRVectorLayer.h"

#include "Minerva/Core/Factory/Readers.h"

#include "boost/filesystem.hpp"

using namespace Minerva::Layers::GDAL;

///////////////////////////////////////////////////////////////////////////////
//
//  Register readers with the factory.
//
///////////////////////////////////////////////////////////////////////////////

namespace
{
  namespace MF = Minerva::Core::Factory;
  MF::RegisterReader _readerForOGR ( new OGRReader );
}

USUL_IMPLEMENT_IUNKNOWN_MEMBERS ( OGRReader, OGRReader::BaseClass );


///////////////////////////////////////////////////////////////////////////////
//
//  Constructor.
//
///////////////////////////////////////////////////////////////////////////////

OGRReader::OGRReader() : BaseClass(),
  _filters()
{
  _filters.push_back ( Filter ( "ESRI Shape File (*.shp)", "*.shp" ) );
}


///////////////////////////////////////////////////////////////////////////////
//
//  Destructor.
//
///////////////////////////////////////////////////////////////////////////////

OGRReader::~OGRReader()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//  Query for interface.
//
///////////////////////////////////////////////////////////////////////////////

Usul::Interfaces::IUnknown* OGRReader::queryInterface ( unsigned long iid )
{
  switch ( iid )
  {
    case Usul::Interfaces::IUnknown::IID:
    case Minerva::Common::IReadFeature::IID:
      return static_cast<Minerva::Common::IReadFeature*> ( this );
    default:
      return 0x0;
  }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Get the filters for this reader.
//
///////////////////////////////////////////////////////////////////////////////

OGRReader::Filters OGRReader::filters() const
{
  return _filters;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Can this reader handle the extension?
//
///////////////////////////////////////////////////////////////////////////////

bool OGRReader::canHandle ( const std::string& extension ) const
{
  for ( Filters::const_iterator iter = _filters.begin(); iter != _filters.end(); ++iter )
  {
    const std::string ext ( boost::filesystem::extension ( iter->second ) );
    if ( ext == extension )
    {
      return true;
    }
  }
  
  return false;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Read
//
///////////////////////////////////////////////////////////////////////////////

Minerva::Core::Data::Feature* OGRReader::readFeature ( const std::string& filename )
{
  OGRVectorLayer::RefPtr feature ( new OGRVectorLayer );
  feature->read ( filename );
  return feature.release();
}
